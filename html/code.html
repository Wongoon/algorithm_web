<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Sorting Visualizer Web</title>
    <link rel="icon" href="../images/icon.svg">
    <link rel="stylesheet" href="../css/main.css">
    <link rel="stylesheet" href="../css/code.css">
    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/tomorrow-night-bright.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
</head>

<body class="">
    <header>
        <ul class="nav">
            <li><a href="../index.html">홈</a></li>
            <li id="sub"><a href="#" class="dontmove">정렬</a>
                <ul class="nav_in up">
                    <li><a href="sorting/selection.html">단순 선택 정렬</a></li>
                    <li><a href="sorting/insertion.html">단순 삽입 정렬</a></li>
                    <li><a href="sorting/bubble.html">버블 정렬</a></li>
                    <li><a href="sorting/shell.html">셸 정렬</a></li>
                    <li><a href="sorting/quick.html">퀵 정렬</a></li>
                    <li><a href="sorting/heap.html">힙 정렬</a></li>
                    <li><a href="sorting/merge.html">합병 정렬</a></li>
                    <li><a href="sorting/radix.html">기수 정렬</a></li>
                </ul>
            </li>
            <li><a href="compare.html">비교</a></li>
            <li><a href="code.html">코드</a></li>
        </ul>
    </header>

    <div class="container">
        <ul class="tabmenu">
            <li class="tablink current" data-tab="selection">단순 선택 정렬</li>
            <li class="tablink" data-tab="insertion">단순 삽입 정렬</li>
            <li class="tablink" data-tab="bubble">버블 정렬</li>
            <li class="tablink" data-tab="shell">셸 정렬</li>
            <li class="tablink" data-tab="quick">퀵 정렬</li>
            <li class="tablink" data-tab="heap">힙 정렬</li>
            <li class="tablink" data-tab="merge">합병 정렬</li>
            <li class="tablink" data-tab="radix">기수 정렬</li>
        </ul>

        <div class="content">
            <div id="selection" class="contents current">
                <div class="codes">
                    <div class="js">
                        <div class="title">Javascript</div>
<pre style="--h: 300px;">
<code class="language-javascript">
async function selection(){
    const ele = document.querySelectorAll(".bar");
    for(let i = 0; i < ele.length; i++){
        let min_index = i;
        for(let j = i+1; j < ele.length; j++){
            if(parseInt(ele[j].style.height) < parseInt(ele[min_index].style.height)){
                min_index = j;
            }
        }
        swap(ele[min_index], ele[i]);
    }
}
</code>
</pre>
                    </div>
                    <div class="java">
                        <div class="title">Java</div>
<pre style="--h: 300px;">
<code class="language-javascript">
void selectionSort(int[] a, int n) {
    for(int i = 0; i < n - 1; i++) {
        int min = i;
        for(int j = i + 1; j < n; j++){
            if(a[j] < a[min]){
                min = j;
            }
        }
        swap(a, i, min);
    }
}
</code>
</pre>
                    </div>
                </div>
                <div class="describe">
                    <div class="bigO">
                        <div class="best">최선의 경우 (Best) : <span class="value">O(n<sup>2</sup>)</span></div>
                        <div class="average">평균 (Average) : <span class="value">O(n<sup>2</sup>)</span></div>
                        <div class="worst">최악의 경우 (Worst) : <span class="value">O(n<sup>2</sup>)</span></div>
                    </div>
                    <div class="description">
                        Selection Sort는 해당 순서에 원소를 넣을 위치는 이미 정해져 있고, 어떤 원소를 넣을지 선택하는 알고리즘이다. Selection Sort와 Insertion Sort를 헷갈려하는 사람들이 종종 있는데, Selection Sort는 배열에서 해당 자리를 선택하고 그 자리에 오는 값을 찾는 것이라고 생각하면 편하다. 선택 정렬의 과정으로는 먼저 주어진 배열에서 최솟값을 찾아 그 값을 맨 앞에 위치한 값과 교체한다. 그 다음 맨 처음 위치를 뺀 나머지 리스트를 앞과 같은 방법으로 교체한다. 하나의 원소만 남을 때까지 이를 반복한다.
                    </div>
                </div>
            </div>

            <div id="insertion" class="contents">
                <div class="codes">
                    <div class="js">
                        <div class="title">Javascript</div>
<pre style="--h: 320px;">
<code class="language-javascript">
async function insertion(){
    const ele = document.querySelectorAll(".bar");
    for(let i = 1; i < ele.length; i++){
        let j = i - 1;
        let key = ele[i].style.height;

        while(j >= 0 && (parseInt(ele[j].style.height) > parseInt(key))){
            ele[j + 1].style.height = ele[j].style.height;
            j--;
        }
        ele[j + 1].style.height = key;
    }
}
</code>
</pre>
                    </div>
                    <div class="java">
                        <div class="title">Java</div>
<pre style="--h: 320px;">
<code class="language-javascript">
void insertionSort(int[] a, int n) {
	for(int i = 1; i < n; i++) {
		int j;
		int tmp = a[i];
		for(j = i; j > 0 && a[j-1] > tmp; j--)
			a[j] = a[j-1];
		a[j] = tmp;
	}
}
</code>
</pre>
                    </div>
                </div>
                <div class="describe">
                    <div class="bigO">
                        <div class="best">최선의 경우 (Best) : <span class="value">O(n)</span></div>
                        <div class="average">평균 (Average) : <span class="value">O(n<sup>2</sup>)</span></div>
                        <div class="worst">최악의 경우 (Worst) : <span class="value">O(n<sup>2</sup>)</span></div>
                    </div>
                    <div class="description">
                        Insertion Sort는 자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교 하여, 자신의 위치를 찾아 삽입함으로써 정렬을 완성하는 알고리즘이다. 두 번째 값부터 시작하여 그 앞(왼쪽)의 값들과 비교하여 삽입할 위치를 지정한 후 값을 뒤로 옮기고 지정한 자리에 값을 삽입하여 정렬하는 알고리즘이다.
                    </div>
                </div>
            </div>

            <div id="bubble" class="contents">
                <div class="codes">
                    <div class="js">
                        <div class="title">Javascript</div>
<pre style="--h: 320px;">
<code class="language-javascript">
async function bubble() {
    const ele = document.querySelectorAll(".bar");
    for(let i = 0; i < ele.length - 1; i++){
        for(let j = 0; j < ele.length - i - 1; j++){
            if(parseInt(ele[j].style.height) > parseInt(ele[j + 1].style.height)){
                swap(ele[j], ele[j + 1]);
            }
        }
    }
}
</code>
</pre>
                    </div>
                    <div class="java">
                        <div class="title">Java</div>
<pre style="--h: 320px;">
<code class="language-javascript">
void bubbleSort(int[] a, int n) {
	int k = 0;
	while(k < n-1) {
		int last = n-1;
		for(int j = n-1; j > k; j--) {
			if(a[j-1] > a[j]) {
				swap(a, j-1, j);
				last = j;
			}
		}
		k=last;
	}
}
</code>
</pre>
                    </div>
                </div>
                <div class="describe">
                    <div class="bigO">
                        <div class="best">최선의 경우 (Best) : <span class="value">O(n<sup>2</sup>)</span></div>
                        <div class="average">평균 (Average) : <span class="value">O(n<sup>2</sup>)</span></div>
                        <div class="worst">최악의 경우 (Worst) : <span class="value">O(n<sup>2</sup>)</span></div>
                    </div>
                    <div class="description">
                        Bubble Sort는 서로 인접한 두 원소를 검사하여 정렬하는 알고리즘이다. 인접한 2개의 값을 비교하여 크기가 순서대로 되어 있지 않으면, 즉 두 값 중 작은 값이 큰 값보다 오른쪽에 위치 해 있으면 서로 교환한다. 일반적으로 값의 교환 작업이 값의 이동 작업보다 더 복잡하기 때문에 버블 정렬은 단순성에도 불구하고 거의 쓰이지 않는다.
                    </div>
                </div>
            </div>

            <div id="shell" class="contents">
                <div class="codes">
                    <div class="js">
                        <div class="title">Javascript</div>
<pre style="--h: 460px;">
<code class="language-javascript">
async function shellSort() {
    const elements = document.querySelectorAll('.bar');
    const n = elements.length;
    let gap = Math.floor(n / 2);

    while(gap > 0) {
        for(let i = gap; i < n; i++) {
            const current = elements[i];
            const currentValue = parseInt(current.style.height);
            let j = i;

            while(j >= gap && parseInt(elements[j - gap].style.height) > currentValue) {
                swap(elements[j], elements[j - gap]);

                j -= gap;
            }
        }
        gap = Math.floor(gap / 2);
    }
}
</code>
</pre>
                    </div>
                    <div class="java">
                        <div class="title">Java</div>
<pre style="--h: 460px;">
<code class="language-javascript">
void shellSort(int[] a, int n) {
    for(int h = n / 2; h > 0; h /= 2){
        for(int i = h; i < n; i++) {
            int j;
            int tmp = a[i];
            for(j = i - h; j >= 0 && a[j] > tmp; j -= h)
                a[j + h] = a[j];
            a[j + h] = tmp;
        }
    }
}
</code>
</pre>
                    </div>
                </div>
                <div class="describe">
                    <div class="bigO"><span class="value"></span>
                        <div class="best">최선의 경우 (Best) : <span class="value">O(n)</span></div>
                        <div class="average">평균 (Average) : <span class="value">O(n<sup>1.5</sup>)</span></div>
                        <div class="worst">최악의 경우 (Worst) : <span class="value">O(n<sup>2</sup>)</span></div>
                    </div>
                    <div class="description">
                        Shell Sort는 Insertion Sort를 보완한 알고리즘으로, Insertion Sort의 최대 문제점인 전체의 리스트를 한 번에 정렬해 삽입되어야 할 위치가 현재 위치에서 상당히 멀리 떨어진 곳이라면 많은 이동을 해야만 제자리로 갈 수 있는 것인데, Shell Sort은 전체의 리스트를 한 번에 정렬하지 않고 일정 기준에 따라 분류 해 정렬하기 때문에 Insertion Sort보다 더 빠르게 정렬할 수 있다.
                    </div>
                </div>
            </div>

            <div id="quick" class="contents">
                <div class="codes">
                    <div class="js">
                        <div class="title">Javascript</div>
<pre style="--h: 490px;">
<code class="language-javascript">
async function partitionLomuto(ele, l, r){
    let i = l - 1;
    for(let j = l; j <= r - 1; j++){
        if(parseInt(ele[j].style.height) < parseInt(ele[r].style.height)){
            i++;
            swap(ele[i], ele[j]);
        }
    }
    i++;
    swap(ele[i], ele[r]);

    return i;
}

async function quickSort(ele, l, r){
    if(l < r){
        let pivot_index = await partitionLomuto(ele, l, r);
        await quickSort(ele, l, pivot_index - 1);
        await quickSort(ele, pivot_index + 1, r);
    }
}
</code>
</pre>
                    </div>
                    <div class="java">
                        <div class="title">Java</div>
<pre style="--h: 490px;">
<code class="language-javascript">
void quickSort(int[] a, int left, int right) {
	int pl = left;
	int pr = right;
	int x = a[(pl + pr) / 2];

	do {
		while(a[pl] < x) pl++;
		while(a[pr] > x) pr--;
		if(pl <= pr) swap(a, pl++, pr--);
	} while(pl <= pr);
		
	if(left < pr) quickSort(a, left, pr);
	if(right > pl) quickSort(a, pl, right);
}
</code>
</pre>
                    </div>
                </div>
                <div class="describe">
                    <div class="bigO">
                        <div class="best">최선의 경우 (Best) : <span class="value">O(n log n)</span></div>
                        <div class="average">평균 (Average) : <span class="value">O(n log n)</span></div>
                        <div class="worst">최악의 경우 (Worst) : <span class="value">O(n<sup>2</sup>)</span></div>
                    </div>
                    <div class="description">
                        퀵 정렬이란, 피벗을 설정하여 이를 올바른 위치로 이동시킨 뒤 나머지 원소들을 두 개의 배열로 분할하여 재귀적으로 정렬시키는 알고리즘이다. 배열을 균등하게 분할하는 합병 정렬과 달리, 배열이 불균등하게 분할 된다. 퀵 정렬은 두 가지 부분으로 이루어져 있는데, 첫째는 pivot을 설정하고 이를 올바른 위치로 이동시키는 부분이다. pivot이 올바른 위치에 있다는 것은 pivot의 앞쪽에 pivot보다 작거나 같은 수들만 존재하고 pivot의 뒤쪽보다 pivot보다 크거나 같은 수들만 존재한다는 의미이다. 둘째는 pivot을 제외한 나머지 원소들을 두 배열로 분할해 재귀적으로 정렬시키는 부분이다. 피벗의 올바른 위치가 인덱스 r일 때, 전체 배열을 arr[시작 ~ r]과 arr[r ~ 끝]으로 분할하고, 각각의 배열을 정렬하여 최종 정렬을 완성한다.
                    </div>
                </div>
            </div>


            <div id="heap" class="contents">
                <div class="codes">
                    <div class="js">
                        <div class="title">Javascript</div>
<pre style="--h: 860px;">
<code class="language-javascript">
async function heapSort(arr, n) {
    for(var i = n / 2 - 1; i >= 0; i--) {
        await heapify(arr, n, i);
    }

    for(var i = n - 1; i > 0; i--) {
        var temp = arr[0];
        arr[0] = arr[i];
        arr[i] = temp;
        swap(arr[0], arr[i]);

        await heapify(arr, i, 0);
    }
}

async function heapify(arr, n, i) {
    var largest = i;
    var l = 2 * i + 1;
    var r = 2 * i + 2;

    if(l < n && parseInt(arr[l].style.height) > parseInt(arr[largest].style.height)) {
        largest = l;
        swap(arr[largest], arr[l]);
    }

    if(r < n && parseInt(arr[r].style.height) > parseInt(arr[largest].style.height)) { 
        largest = r;
        swap(arr[largest], arr[r]);
    }

    if(largest != i) {
        var temp = arr[i];
        arr[i] = arr[largest];
        arr[largest] = temp;
        swap(arr[i], arr[largest]);

        heapify(arr, n, largest);
    }
}
</code>
</pre>
                    </div>
                    <div class="java">
                        <div class="title">Java</div>
<pre style="--h: 860px;">
<code class="language-javascript">
public void heapSort(int[] arr) {
    int n = arr.length;

    for(int i = n / 2 - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }

    for(int i = n - 1; i > 0; i--) {
        int temp = arr[0];
        arr[0] = arr[i];
        arr[i] = temp;

        heapify(arr, i, 0);
    }
}

void heapify(int[] arr, int n, int i) {
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;

    if(left < n && arr[left] > arr[largest]) {
        largest = left;
    }

    if(right < n && arr[right] > arr[largest]) {
        largest = right;
    }

    if(largest != i) {
        int temp = arr[i];
        arr[i] = arr[largest];
        arr[largest] = temp;

        heapify(arr, n, largest);
    }
}
</code>
</pre>
                    </div>
                </div>
                <div class="describe">
                    <div class="bigO">
                        <div class="best">최선의 경우 (Best) : <span class="value">O(n log n)</span></div>
                        <div class="average">평균 (Average) : <span class="value">O(n log n)</span></div>
                        <div class="worst">최악의 경우 (Worst) : <span class="value">O(n log n)</span></div>
                    </div>
                    <div class="description">
                        힙 정렬이란, 최대 힙 트리 혹은 최소 힙 트리를 구성해 정렬을 하는 방법으로써, 내림차순 정렬을 하는 경우 최대 힙 트리를 구성하고, 오름차순 정렬을 하는 경우 최소 힙 트리를 구성한다. 정렬 과정으로는 n개의 노드에 대한 완전 이진 트리를 구성한다. 이때 루트 노드부터 부모 노드, 왼쪽 자식 노드, 오른쪽 자식 노드 순으로 구성한다. 그 후 최소 힙을 구성한다. 최대 힙이란 부모 노드가 자식 노드보다 큰 트리를 말하는데, 단말 노드를 자식 노드로 가진 부모 노드부터 구성하며 아래부터 루트까지 올라오며 순차적으로 만들어 갈 수 있다. 최소 힙을 구성한 이후 가장 큰 수(루트에 위치)를 가장 끝의 노드와 교환한다. 그 후 정렬이 끝날 때까지 2와 3을 반복한다.
                    </div>
                </div>
            </div>

            <div id="merge" class="contents">
                <div class="codes">
                    <div class="js">
                        <div class="title">Javascript</div>
<pre style="--h: 1000px;">
<code class="language-javascript">
async function merge(ele, low, mid, high){
    const n1 = mid - low + 1;
    const n2 = high - mid;
    let left = new Array(n1);
    let right = new Array(n2);

    for(let i = 0; i < n1; i++){
        left[i] = ele[low + i].style.height;
    }
    for(let i = 0; i < n2; i++){
        right[i] = ele[mid + 1 + i].style.height;
    }
    let i = 0, j = 0, k = low;
    while(i < n1 && j < n2){
        if(parseInt(left[i]) <= parseInt(right[j])){
            ele[k].style.height = left[i];
            i++;
            k++;
        }
        else{
            ele[k].style.height = right[j];
            j++;
            k++;
        }
    }
    while(i < n1){
        ele[k].style.height = left[i];
        i++;
        k++;
    }
    while(j < n2){
        ele[k].style.height = right[j];
        j++;
        k++;
    }
}

async function mergeSort(ele, l, r){
    if(l >= r){
        return;
    }
    const m = l + Math.floor((r - l) / 2);
    await mergeSort(ele, l, m);
    await mergeSort(ele, m + 1, r);
    await merge(ele, l, m, r);
}
</code>
</pre>
                    </div>
                    <div class="java">
                        <div class="title">Java</div>
<pre style="--h: 1000px;">
<code class="language-javascript">
public void mergeSort(int[] arr) {
    int n = arr.length;
    if(n <= 1) {
        return;
    }
    int mid = n / 2;

    int[] left = new int[mid];
    int[] right = new int[n - mid];

    System.arraycopy(arr, 0, left, 0, mid);
    System.arraycopy(arr, mid, right, 0, n - mid);

    mergeSort(left);
    mergeSort(right);

    merge(arr, left, right);
}

private void merge(int[] arr, int[] left, int[] right) {
    int i = 0;
    int j = 0;
    int k = 0;

    while(i < left.length && j < right.length) {
        if(left[i] <= right[j]) {
            arr[k++] = left[i++];
        }
        else {
            arr[k++] = right[j++];
        }
    }

    while(i < left.length) {
        arr[k++] = left[i++];
    }

    while(j < right.length) {
        arr[k++] = right[j++];
    }
}
</code>
</pre>
                    </div>
                </div>
                <div class="describe">
                    <div class="bigO">
                        <div class="best">최선의 경우 (Best) : <span class="value">O(n log n)</span></div>
                        <div class="average">평균 (Average) : <span class="value">O(n log n)</span></div>
                        <div class="worst">최악의 경우 (Worst) : <span class="value">O(n log n)</span></div>
                    </div>
                    <div class="description">
                        합병 정렬은 비교 기반의 분할 정복 알고리즘 중 하나이며, 안정 정렬에 속한다. 합병 정렬의 과정은 퀵 정렬처럼 하나의 배열을 두 배열로 분할해 재귀적으로 정렬하는 알고리즘이다. 하지만 퀵 정렬의 경우 피벗 값에 따라 배열을 편향되게 분할할 가능성이 있지만 합병 정렬의 경우 퀵 정렬보다 느리지만 피벗 값이 없고 반절씩 나눈다는 점에서 최악의 경우에도 시간 복잡도가 평균의 시간 복잡도와 똑같다. 합병 정렬의 정렬 방식은 정렬되지 않은 배열을 절반으로 잘라 비슷한 크기의 두 부분 리스트로 나눈다. 각 부분의 배열을 재귀적으로 합병 정렬을 이용해 정렬한다. 두 부분의 배열을 다시 하나의 정렬된 배열로 합병한다. 이때 정렬 결과가 임시 배열에 저장된다. 임시 배열에 저장된 결과를 원래 배열에 인덱스가 일치하게 복사한다.
                    </div>
                </div>
            </div>

            <div id="radix" class="contents">
                <div class="codes">
                    <div class="js">
                        <div class="title">Javascript</div>
<pre style="--h: 730px;">
<code class="language-javascript">
async function radixSort(ele, arrOfNums) {
    let maxDigitCount = mostDigits(arrOfNums);
    for (let k = 0; k < maxDigitCount; k++) {
        let digitBuckets = Array.from({ length: 10 }, () => []);
        for (let i = 0; i < arrOfNums.length; i++) {
            let digit = getDigit(arrOfNums[i], k);
            digitBuckets[digit].push(arrOfNums[i]);
        }
        arrOfNums = [].concat(...digitBuckets);
    }
}

function getDigit(num, p){
    return Math.floor(Math.abs(num) / Math.pow(10, p)) % 10;
}

function digitCount(num) {
    if (num === 0){
        return 1;
    }
    return Math.floor(Math.log10(Math.abs(num))) + 1;
}

function mostDigits(nums) {
    let maxDigits = 0;
    for (let i = 0; i < nums.length; i++) {
        if(hasPressedStop){
            return;
        }
        maxDigits = Math.max(maxDigits, digitCount(nums[i]));
    }
    return maxDigits;
}
</code>
</pre>
                    </div>
                    <div class="java">
                        <div class="title">Java</div>
<pre style="--h: 730px;">
<code class="language-javascript">
public static void radix_Sort(int n, int[] arr) {
	Queue<Integer>[] bucket = new LinkedList[bucketSize];
	for (int i = 0; i < bucketSize; ++i) {
		bucket[i] = new LinkedList<>();
	}

	int factor = 1;

	for (int d = 0; d < 2; ++d) {
		for (int i = 0; i < n; ++i) {
			bucket[(arr[i] / factor) % 10].add(arr[i]);
		}

		for (int i = 0, j = 0; i < bucketSize; ++i) {
			while (!bucket[i].isEmpty()) {
				arr[j++] = bucket[i].poll();
			}
		}

		factor *= 10;
	}
}
</code>
</pre>
                    </div>
                </div>
                <div class="describe">
                    <div class="bigO">
                        <div class="best">최선의 경우 (Best) : <span class="value">O(nw)</span></div>
                        <div class="average">평균 (Average) : <span class="value">O(nw)</span></div>
                        <div class="worst">최악의 경우 (Worst) : <span class="value">O(nw)</span></div>
                        <span class="plusdescribe">w : 키의 길이</span>
                    </div>
                    <div class="description">
                        기수 정렬은 데이터끼리의 직접적인 비교를 이용하는 다른 정렬 알고리즘과는 달리 데이터끼리의 직접적인 비교 없이 정렬을 수행한다. 비교를 이용한 정렬이 아니기 때문에 w가 상수일 경우 시간복잡도가 O(n)으로 퀵 정렬보다 빠른 시간 복잡도가 가능하다. 하지만 이 경우에는 자릿수가 적은 4Byte의 정수 등에서나 제대로 된 성능을 발휘할 수 있으며, 자릿수가 무한에 가까운 경우나 문자열 정렬 등에 사용할 경우 오히려 퀵 정렬보다 느릴 수 있으며, 부동 소수점의 경우는 부호 여부, 지수부, 가수부에 대해 각각 기수 정렬을 실행해야 한다. 정렬 방식은 먼저 데이터가 x진법이라고 가정할 때, 0번부터 x-1까지의 배열을 만들어 놓고, 각 데이터를 순서대로 현재 자릿수의 숫자가 가리키는 배열에 push하고, 배열을 0번부터 x-1까지 순서대로 이어 붙인다. 이 과정을 가장 낮은 자릿수부터 가장 높은 자릿수까지 반복하거나 가장 높은 자릿수부터 가장 낮은 자릿수까지 반복하면 정렬이 끝난다. 가장 낮은 자릿수부터 반복하는 경우 LSD, 가장 높은 자릿수부터 반복하는 경우 MSD를 사용하게 된다. 하지만 MSD의 경우 특정 구현 방식에서는 불안정 정렬이므로 중복 키의 원래 순서를 항상 유지하지 않는다.
                    </div>
                </div>
            </div>
        </div>

        <footer class="up">
            <div class="bt_submenu">
                <ul class="bt_nav">
                    <li><a href="../index.html">홈</a></li>
                    <li id="bt_sub"><span>정렬</span>
                        <ul class="bt_nav_in up">
                            <li><a href="sorting/selection.html">단순 선택 정렬</a></li>
                            <li><a href="sorting/insertion.html">단순 삽입 정렬</a></li>
                            <li><a href="sorting/bubble.html">버블 정렬</a></li>
                            <li><a href="sorting/shell.html">셸 정렬</a></li>
                            <li><a href="sorting/quick.html">퀵 정렬</a></li>
                            <li><a href="sorting/heap.html">힙 정렬</a></li>
                            <li><a href="sorting/merge.html">합병 정렬</a></li>
                            <li><a href="sorting/raidx.html">기수 정렬</a></li>
                        </ul>
                    </li>
                    <li><a href="compare.html">비교</a></li>
                    <li><a href="code.html">코드</a></li>
                </ul>
            </div>
            <div class="footer_bt">
                <div class="copyright">
                    <h5>COPYRIGHT © by WEB DESIGN ALL RIGHTS RESERVED</h5>
                </div>
                <div class="darkmode">
                    <div id="btn">
                        <i class="indicator"></i>
                    </div>
                </div>
            </div>
        </footer>
        <script src="../js/main.js" type="text/javascript"></script>
        <script src="../js/code.js" type="text/javascript"></script>
</body>

</html>